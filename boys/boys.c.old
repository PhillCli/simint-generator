#include <stdlib.h>
#include <math.h>
#include <stdio.h>

#include "boys/boys.h"


#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

extern double boyspt[21][301];

// Functions for use only in this file
void Boys_F_recur(double * F, int n, double x);
void Boys_F_recur_old(double * F, int n, double x);
void Boys_F_short(double * F, int n, double x);
void Boys_F_long(double * F, int n, double x);



#ifdef SIMINT_SIMD
  #pragma omp declare simd simdlen(4)
#endif
void Boys_F(double * F, int n, double x)
{
    Boys_F_recur(F, n, x);
//    if(x > 29.0)
//        Boys_F_long(F, n, x);
//    else
//        Boys_F_short(F, n, x);
}

void Boys_F_short(double * F, int n, double x)
{
    int i;
    int idx = (int)((x+0.5)*10.0); // rounding, assuming x is positive
    double dx = (((double)idx / 10.0)-x);
    double fac = 1.0;
    double ex = exp(-x);
    double x2ex = 2 * x * ex;

    F[n] = 0;
    for(i = 0; i <= BOYS_INTERP_ORDER; i++)
    {
        F[n] += boyspt[n+i][idx]*pow(dx, i)/fac;
        fac *= (i+1);
    }

    // recurse down
    for(i = n-1; i >= 0; --i)
        F[i] = (x2ex * F[i+1])/(2*i + 1);
}

void Boys_F_long(double * F, int n, double x)
{
    double dfac = 1;
    double ex = exp(-x);
    double x2ex = 2 * x * ex;
    int i;

    if(n > 1)
    {
        for(i = n; i > 1; i-= 2)
            dfac *= i;
    }

    F[n] = dfac / (1<<(n+1)) * sqrt(M_PI / pow(x, 2*n+1));

    // recurse down
    for(i = n-1; i >= 0; --i)
        F[i] = (x2ex * F[i+1])/(2*i + 1);
}


void Boys_F_recur(double * F, int n, double x)
{
    const double t2 = 1.0/(2.0 * x);
    const double et = exp(-x);
    const double K = 1.0 / 1.12837916709551257390;
    const double x2 = sqrt(x);
    F[0] = K * erf(x2) / x2;

    int m21, m;
    double newf;

    for (m = 0, m21 = 1; m < n; m++, m21 += (m+m))
    {
      // recurse up
      F[m+1] = (m21 * F[m] - et) * t2;

      // and down
      newf = (2*x*F[m+1] + et)/m21;
      printf("F: %12.8e  newf: %12.8e  Diff: %12.8e\n", F[m], newf, newf-F[m]); 

      // add on the error
      double eps = (newf - F[m]) * m21 * t2;
      printf("n = %3d EPS: %12.8e\n", m, eps);
      F[m+1] += eps;
    }
}

void Boys_F_recur_old(double * F, int n, double x)
{
    const double t2 = 1.0/(2.0 * x);
    const double et = exp(-x);
    const double K = 1.0 / 1.12837916709551257390;
    x = sqrt(x);
    F[0] = K * erf(x) / x;

    int m21, m;

    for (m = 0, m21 = 1; m < n; m++, m21 += (m+m))
      F[m + 1] = (m21 * F[m] - et) * t2;
}
/*
void Boys_F_recur_old2(double * F, int n, double x)
{
    const double t2 = 1.0/(2.0 * x);
    const double et = exp(-x);
    const double E = -et * t2;
    //const double AE = F[0]+E;
    const double K = 1.0 / 1.12837916709551257390;
    x = sqrt(x);
    F[0] = K * erf(x) / x;
    F[1] = t2 * F[0] + E;

    //F[2] = 3 * t2 * (t2 * F[0] + E) + E;
    printf(" K: %12.8e  E: %12.8e\n",K, E);
    printf("F0: %12.8e\n", F[0]);

    double ffac = t2;
    double sfac = 0;

    int m;
    int m21;  // strides through 2m - 1
    double m21t2; // holds m21 * t2
    for(m = 2, m21 = 3; m <= n; m++, m21 += 2)
    {
        m21t2 = m21 * t2;
        ffac *= m21t2;
        sfac = (sfac + 1) * m21t2;
        printf("m21 = %3d  m21t2 = %12.8e  ffac = %12.8e  sfac = %12.8e\n", m21, m21t2, ffac, sfac);
        F[m] =  ffac * F[0] + sfac * E + E;
    }

    for(m = 2, m21 = 15; m <= n; m++, m21 += 2)
    {
        m21t2 = m21 * t2; 
        F[m] = m21t2 * ( (m21-2)*t2 * ( (m21-4)*t2 * ;
    }

}
*/






// Maximum value needed for Boys function
double Boys_Max(const int ncenter,
                const double * X, const double * Y, const double * Z,
                const int * n_prim_per_center, const double * alpha)
{
    int i, j, a, b;

    /*
    int maxpa = 0;
    int maxpb = 0;
    */

    double maxd = 0;
    double d, d2;

    int pa = 0; // counts over alpha
    int pb = 0; // counts over alpha

    // these hold the start of this center in the alpha array
    int paorig = 0;
    int pborig = 0;

    for(i = 0; i < ncenter; i++)
    {
        pborig = 0;
        for(j = 0; j < ncenter; j++)
        {
            d = (X[i]-X[j])*(X[i]-X[j])
              + (Y[i]-Y[j])*(Y[i]-Y[j])
              + (Z[i]-Z[j])*(Z[i]-Z[j]);

            pa = paorig;
            for(a = 0; a < n_prim_per_center[i]; a++)
            {
                pb = pborig;
                for(b = 0; b < n_prim_per_center[j]; b++)
                {

                    d2 = d * (alpha[pa]*alpha[pb]) / (alpha[pa] + alpha[pb]);
                    if(d2 > maxd)
                    {
                        /*
                        maxpa = pa;
                        maxpb = pb;
                        */
                        maxd = d2;
                    }
                    pb++;
                }
                pa++;
            }
            pborig += n_prim_per_center[j];
        }
        paorig += n_prim_per_center[i];
    }

    //printf("Max i, j: %d %d\n", maxpa, maxpb);

    // missing a factor of 2
    return 2.0 * maxd;;
}
